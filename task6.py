# множество
# create
a = {} # пустое множество
b = set() # пустое множество
c = frozenset() # пустое неизменяемое множество
a = {1, 1.1, 'a', (1, 1.1), None,True, print} # множество в котором: целое; вещественное; строковое; кортеж; пустой тип; булевый тип; встроенная функцияю
a = {1, 1.1, [1, 2]} # обмануть встроенные проверки добавлением списка в кортеж не получиться, возникнет ошибка
a = frozenset({1, 1.1}) # так создается неизменяемое множество
a = [1, 'abc', 1] # раньше я был списком
set(a) # {1, 'abc', 1}, но 'a' остался списком
b = set('слово') # { 'с' , 'л' , 'в'}
c = frozenset('hello') # {'h', 'e', 'l', 'o'}
d = set([1, [2.1], 1]) # ошибка, внутри ест изменяемый тип
# retrive
a = {1, 1.1, 'a'}
a.add('привет') # теперь в 'a' {1, 1.1, 'a', 'привет'
b = 1
a.add(b) # так b = 1 то во множество она не добавиться  так как там уже есть 1
a = {1, 2, 3}
a.update({5, 2}) # доюавляет значения (объекты) во множество из другого множества. Помним что во множестве элементы уникальные. Теперь "a" {1, 2, 3, 5}
a = {1, 1.1, 'a'}
a[0] # ошибка
# update
a = {1, 1.1, 'a'}
a = [0] = 'a' # ошибка
a = {1, 2, 3} # теперь 'a' равно {1, 2, 3}
# delete
a = {1, 1.1, 'a'}
del a[0] # ошибка
del a # полное удаление переменной "a"
a = {1, 2, 3}
a.clear() # очищает множество, делая его пустым. теперь "a" {2, 3, 4}
a = {1, 2, 3, 4}
a.pop() # 1. возвращает элемент из множества. Теперь "a" {2, 3, 4}.
a.remove(3) # удаление передаваемого элемента из множества. Теперь "a" {2, 4}.  Если такого элемента не сущаествует, то вызовется ошибка
a.discard(5) # None. тоже удаляет значение или обьект, но в отличие от remove не вызывает ошибку, если данного значения нет во множестве, а по умолчанию возвращает  None. "a" стался {2, 4}
# методы
help(set) # инф о множествах
a = {1, 2, 3}
a.copy() # {1, 2, 3}. Возвращает копию множества
a.isdisjoint({4, 5, 6}) # true. проверяет что между множествами нет общих элементов
a.issubset({4, 3, 1, 2}) # true. Ппроверяет, что множество "a" является подмножество {4, 3, 1, 2}
a.issuperset({2, 1}) # true. проверяет что множество "a" является охватывающим множеством {2, 1}. т.е. что {2, 1} содержится в множестве "a"

# кортеж
# create
a = [1, 2.1, 3] # раньше я был списком
tuple(a) # (1, 2.1, 3) но 'a' остался списком
b = tuple('abc') # ('a', 'b', 'c')
# retrive
a = (1, 1.1, 'a')
print(a) # (1, 1.1, 'a')
print((1, 1.1, 'a')) # (1, 1.1, 'a')
a = (1, 1.1, 'a')
a[0] # 1
a[1] # 1.1
a[2] # 'a'
a[3] # ошибка, вышли за границы
a[-1] # 'a'
a[-2] # 1.1
a[-3] # 1
a[-4] # ошибка, вышли за границы
# update
a = (1, 1.1, 'a')
a[0] # ошибка
a = (1, 2, 3) #  Теперь 'a' равно (1, 2, 3)
a = (1, 1.1, 'a')
del a[0] # ошибка
del a # полное удаление переменной "a"

